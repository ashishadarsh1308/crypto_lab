def _gcd(p, q):
    # Gives gcd of two numbers p and q
    if q == 0:
        return p
    return _gcd(q, p % q)

def exteuclid(a, b):
    # Extended Euclidean algorithm to find the multiplicative inverse    
    r_1 = a
    r_2 = b
    s_1 = int(1)
    s_2 = int(0)
    t_1 = int(0)
    t_2 = int(1)
    while r_2 > 0:
        temp = r_1 // r_2
        r = r_1 - temp * r_2
        r_1 = r_2
        r_2 = r
        s = s_1 - temp * s_2
        s_1 = s_2
        s_2 = s
        t = t_1 - temp * t_2
        t_1 = t_2
        t_2 = t
    if t_1 < 0:
        t_1 = t_1 % a

    return (r_1, t_1)

# Input for prime numbers p and q
p = int(input("Enter a prime number p: "))
q = int(input("Enter a prime number q: "))

n = p * q
# phi_n
Pn = (p - 1) * (q - 1)

# Encryption key generation in range 1 < e < Pn
possible_key = []

for i in range(2, Pn):
    gcd = _gcd(Pn, i)  
    if gcd == 1:
        possible_key.append(i)

# An encryption key is selected from the list of keys
e = int(-1)
# The multiplicative inverse of the generated key is computed
for key in possible_key:
    r, d = exteuclid(Pn, key)
    if r == 1:
        d = int(d)
        e = int(key)
        print("Encryption Key is: ", e)
        print("Decryption Key is: ", d)
    if e != -1:
        break

if e == -1:
    print("No possible encryption key!!!")
    exit(0)

# Input for the message M
M = int(input("Enter the message M to be sent in numeric: "))

# Signature is created by Andy
S = (M**d) % n
print("Signature generated by Andy: ", S)

# Andy sends the message M and Signature S to Bert
# Bert generates a Message M1 using the Signature S and Andy's Public Key (e,n)
M1 = (S**e) % n

# If M = M1 only then Bert accepts the message sent by Andy.
if M == M1:
    print(f"As M == M1: M = {M}, M1 = {M1}, Signature Valid : TRUE!")
else:
    print(f"As M not equal to M1: M = {M}, M1 = {M1}, Signature Valid : FALSE!")
